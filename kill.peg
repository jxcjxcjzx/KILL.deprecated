{
function Token(tag, value=undefined, isKeyword = false, isOperator = false) {
	this.tag = tag;
    this.value = value || [];
    this.isKeyword = function() {return isKeyword;};
    this.isOperator = function() {return isOperator;};
};

var keywords = [];

function keyword(tag) {
    keywords.push(tag);
    return new Token(tag, undefined, true, false);
}

function operator(tag) {
    return new Token(tag, undefined, false, true);
}

function string(value) {
	return new Token("string", value);
}

function identifier(value, access = undefined) {
    return new Token("id", {object: value, accessor: access});
}

function number(value) {
    return new Token("number", value);
}

var Kif = keyword("if");
var Kthen = keyword("then");
var Kelse = keyword("else");
var Kend = keyword("end");
var Klet = keyword("let");
var Kin = keyword("in");
var Kbegin = keyword("begin");
var Kset = keyword("set!");
var Klambda = keyword("lambda");

var Ktrue = keyword("true"),
    Kfalse = keyword("false"),
    Kquote = keyword("qoute")

var Oarrow = operator("->");
var Oassign = operator(":=");

function KillObject(type, value = undefined, iterable = false) {
    this.type = type;
    this.value = value;
    this.iterable = iterable;
}

var klist = function (value) {
    return new KillObject("list", value, true);
};

var kunit = function () {
    return new KillObject("unit", "()", true);
}

}

start = stmts

stmts =
  stmt:stmt stmts:(delim+ stmt:stmt {return stmt})* delim?
  {return [stmt].concat(stmts)}

stmt = blank* stmt:(decl / exp) comment? {return stmt;} / comment

comment = blank* t_comment [^#\n]+ {return [];}

decl = let

exp =
  if / begin / set / squote / infixexp

infixexp =
  l:lexp
    {return l}

lexp =
  lambda /
  fexp

if =
  _if:t_if blank* cond:fexp blank* t_then blank* then:fexp blank* t_else blank* _else:fexp
  {return [Kif, cond, then, _else];}

begin =
  t_begin es:(blank* newline? blank* "(" e:exp ")" {return e})+ blank* delim
  { return [Kbegin].concat(es);}

fexp =
  l:aexp blank* rs:(blank* f:aexp {return f.length&&["list","list_comp"].indexOf(f[0]) > -1?[f]:f;})*
  { return rs.length? rs.reduce(function(l,r){return [l].concat(r);},l) : [l];}

aexp =
  literal /
  var /
  quote

let = l:t_let blank+ bs:bindings
{
	return [Klet, bs]
}

bindings =
  b:binding bs:(sep blank* b:binding {return b;})*
  {return [b].concat(bs);}

binding =
  name:identifier blank* op_assign blank* exp:exp
  {return [name, exp];}

lambda =
  ps:param? blank* (op_arrow blank* newline?) blank* exp:exp sep?
  {return [Klambda , ps?[ps]:[], exp];} /
  p:param blank+ exp:exp sep? {return [Klambda, [p],exp]} /
  p:param blank* l:lambda {return [Klambda ,[p], l]}  /
  uc_lambda

uc_lambda = "\\(" id:identifier blank* ids:(sep? blank* id:identifier {return id;})* ")" blank* exp:exp
{
    return ["uc_lambda", [id].concat(ids),exp]
}

set = set:t_set blank* id:identifier blank+ exp:exp
{
	return [Kset, id, exp];
}

newline = "\n"

param = "\\" id:identifier {return id;}
 t_qt = "'"

t_let = "let"
t_if = "if"
t_then = "then"
t_else = "else"
t_begin = "begin"
t_end = "end"
t_set = "set!"
t_in = "in"
t_comment = ";"

op_assign = ":="

op_arrow = "->"

op_access = "#"

blank = [ \t]

delim = "\n"

identifier =
  id:id accessor:accessor_expr*
{ return identifier(id, accessor); }

id = id:[_a-zA-Z?!+\-*/%\^\$\&]+
  &{
  	 if (keywords.indexOf(id.join("")) > -1) {
        //error("keyword "+id.join("") + " cannot be an identifier");
     	return false;
     }
     return true;
   }
{return id.join("")}

accessor_expr = access:op_access method:accessor?
{
    if (method == null) {
       error("must specify accessor after #")
    }
    return method;
}

accessor = access:(id / [0-9]+ )
{
    return typeof(access) == "string"
           ? access
           : access.join("");
}

var = identifier

digits = ds:[0-9]+
{
    return number(parseInt(ds.join(""),10));
}

quote = "(" e:exp es:exp* ")"
  {return es.length? [e].concat(es): [e];}

literal = digits / bools / unit / list

list = "[" l:list_item "]" {return klist(l);} / comprehension

comprehension = "[" blank* exp:exp blank* newline? blank*"|" blank* bind:in_bindings blank* "]"
{
    return ["list_comp",
    		bind,
            bind
                .slice(0)
                .reverse()
                .reduce((a,b) => ["lambda",[b[0]], a],
                        exp)
           ]
}

in_binding =  id:identifier blank* "in" blank* exp:exp cond:(blank* t_if blank* exp:exp blank* {return exp;})?
{
    return cond?[id,[["filter",["lambda",[id], cond]], exp]]:[id, exp]
}

in_bindings = i:in_binding ins:(sep i:in_binding {return i})*
{
    return [i].concat(ins);
}

list_item = exp:exp blank* l:(sep l:list_item {return l;})?
{
    return l
            ?[exp].concat(l)
            :[exp];
}

unit = "(" blank* ")" {return undefined;}

bools = bool:("true" / "false")
{
    return bool == "true" ? Ktrue : Kfalse;
}

squote = t_qt exp:exp {return ["quote"].concat(exp);}

sep = blank* "," newline? blank*
